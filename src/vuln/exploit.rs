use anyhow::{Result, anyhow};
use serde::{Serialize, Deserialize};
use std::process::{Command, Stdio};
use std::time::{Duration, Instant};
use std::{thread, str};
use colored::*;
use chrono::Utc;

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct ExploitResult {
    pub target_ip: String,
    pub target_port: u16,
    pub exploit_name: String,
    pub status: String,
    pub output: String,
    pub timestamp: String,
}

pub struct ExploitConfig<'a> {
    pub exploit_path: &'a str,
    pub args: Vec<&'a str>,
    pub timeout: u64,
    pub retries: u8,
}

pub fn run_exploit(ip: &str, port: u16, config: &ExploitConfig) -> Result<ExploitResult> {
    let mut attempt = 0;
    let mut final_output = String::new();
    let now = Utc::now().to_rfc3339();

    while attempt < config.retries {
        attempt += 1;
        let mut cmd = Command::new(config.exploit_path);
        cmd.args(&config.args);
        cmd.arg(ip);
        cmd.arg(port.to_string());

        println!(
            "{}",
            format!(
                "[EXPLOIT] Running '{}' on {}:{} (Attempt {}/{})",
                config.exploit_path, ip, port, attempt, config.retries
            )
            .bright_magenta()
        );

        let start = Instant::now();

        let output = cmd
            .stdout(Stdio::piped())
            .stderr(Stdio::piped())
            .output();

        match output {
            Ok(output) => {
                let duration = start.elapsed();
                let stdout = str::from_utf8(&output.stdout)?.to_string();
                let stderr = str::from_utf8(&output.stderr)?.to_string();

                final_output = format!(
                    "STDOUT:\n{}\nSTDERR:\n{}\nElapsed: {:.2?}",
                    stdout.trim(),
                    stderr.trim(),
                    duration
                );

                if output.status.success() {
                    println!(
                        "{}",
                        format!(
                            "[EXPLOIT] '{}' executed successfully on {}:{} in {:.2?}",
                            config.exploit_path, ip, port, duration
                        )
                        .green()
                    );

                    return Ok(ExploitResult {
                        target_ip: ip.to_string(),
                        target_port: port,
                        exploit_name: config.exploit_path.to_string(),
                        status: "Success".to_string(),
                        output: final_output,
                        timestamp: now,
                    });
                } else {
                    println!(
                        "{}",
                        format!(
                            "[EXPLOIT] '{}' failed on {}:{} with non-zero exit in {:.2?}",
                            config.exploit_path, ip, port, duration
                        )
                        .yellow()
                    );
                }
            }
            Err(e) => {
                println!(
                    "{}",
                    format!(
                        "[EXPLOIT] Error executing '{}' on {}:{} => {}",
                        config.exploit_path, ip, port, e
                    )
                    .red()
                );
            }
        }

        if attempt < config.retries {
            println!(
                "{}",
                format!(
                    "[EXPLOIT] Retrying '{}' on {}:{} after 3s",
                    config.exploit_path, ip, port
                )
                .cyan()
            );
            thread::sleep(Duration::from_secs(3));
        }
    }

    Err(anyhow!(
        "Exploit '{}' failed after {} attempts",
        config.exploit_path,
        config.retries
    ))
}
